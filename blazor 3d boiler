@page "/cad-viewer"
@using HomagGroup.Blazor3D.Viewers
@using HomagGroup.Blazor3D.Objects
@using HomagGroup.Blazor3D.Materials
@using HomagGroup.Blazor3D.Lights
@using HomagGroup.Blazor3D.Geometries
@using Microsoft.JSInterop

<h3>CAD Viewer</h3>
<div style="position: relative;">
    <Viewer @ref="View3D1" UseDefaultScene="true" Style="width: 100vw; height: 100vh;" />
</div>

@code {
    [Inject] private IJSRuntime JS { get; set; } = default!;
    private Viewer View3D1 = null!;
    private Scene scene = new Scene();
    private Mesh navigationCube;
    private Object3D loadedModel;
    private Vector3 center;
    private float distance;
    private bool isDragging = false;
    private double lastX, lastY;
    private string msg = string.Empty;

    public void Dispose()
    {
        View3D1.ObjectLoaded -= OnObjectLoaded;
        View3D1.JsModuleLoaded -= OnJsModuleLoaded;
    }

    protected override Task OnInitializedAsync()
    {
        AddLights();
        return base.OnInitializedAsync();
    }

    private void AddLights()
    {
        scene.Add(new AmbientLight());
        scene.Add(new PointLight
        {
            Intensity = 0.5f,
            Position = new Vector3(100, 200, 100)
        });
        scene.Add(new PointLight
        {
            Intensity = 1f,
            Position = new Vector3(5, 5, 5)
        });
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Subscribe events
            View3D1.ObjectLoaded += OnObjectLoaded;
            View3D1.JsModuleLoaded += OnJsModuleLoaded;
        }
        return base.OnAfterRenderAsync(firstRender);
    }

    private async Task OnJsModuleLoaded()
    {
        // Configure viewer
        View3D1.ViewerSettings.CanSelect = false; // Disable selection
        View3D1.Scene.BackGroundColor = "White";
        View3D1.OrbitControls.EnablePan = true;
        View3D1.OrbitControls.EnableDamping = true;
        View3D1.OrbitControls.EnableZoom = true;

        // Load STL
        var settings = new ImportSettings
        {
            Format = Import3DFormats.Stl,
            FileURL = "/assets/test.stl"
        };
        loadedModel = await View3D1.Import3DModelAsync(settings);
        scene.Add(loadedModel);

        // Calculate bounding box for camera positioning
        var bbox = new Box3().SetFromObject(loadedModel);
        center = bbox.GetCenter(new Vector3());
        var size = bbox.GetSize(new Vector3());
        distance = Math.Max(size.X, Math.Max(size.Y, size.Z)) * 2;

        // Add navigation cube
        await AddNavigationCube();

        // Set initial camera position
        await View3D1.SetCameraPositionAsync(
            new Vector3(center.X, center.Y, center.Z + distance),
            center
        );
        await View3D1.UpdateScene();
    }

    private async Task AddNavigationCube()
    {
        // Create cube with colored faces
        var geometry = new BoxGeometry { Width = 1, Height = 1, Depth = 1 };
        var materials = new[]
        {
            new MeshBasicMaterial { Color = new Color(0xff0000) }, // Right (+X)
            new MeshBasicMaterial { Color = new Color(0x00ff00) }, // Left (-X)
            new MeshBasicMaterial { Color = new Color(0x0000ff) }, // Top (+Y)
            new MeshBasicMaterial { Color = new Color(0xffff00) }, // Bottom (-Y)
            new MeshBasicMaterial { Color = new Color(0xff00ff) }, // Front (+Z)
            new MeshBasicMaterial { Color = new Color(0x00ffff) }  // Back (-Z)
        };
        navigationCube = new Mesh { Geometry = geometry, Material = materials };
        navigationCube.Scale.Set(0.2f, 0.2f, 0.2f);
        navigationCube.Position.Set(1, -1, -5); // Lower-right corner
        navigationCube.Rotation.Set(MathF.PI / 4, MathF.PI / 4, 0); // Isometric view
        View3D1.Camera.Add(navigationCube); // Parent to camera

        // Handle clicks
        View3D1.OnMouseClick += async (e) =>
        {
            var intersected = await View3D1.RaycastAsync(e.X, e.Y);
            if (intersected != null && intersected.Object == navigationCube)
            {
                var normal = intersected.Face.Normal;
                Vector3 newPosition = new Vector3();

                // Snap to view based on face normal
                if (Math.Abs(normal.Z) > 0.9)
                {
                    newPosition.Set(center.X, center.Y, center.Z + (normal.Z > 0 ? distance : -distance));
                }
                else if (Math.Abs(normal.Y) > 0.9)
                {
                    newPosition.Set(center.X, center.Y + (normal.Y > 0 ? distance : -distance), center.Z);
                }
                else if (Math.Abs(normal.X) > 0.9)
                {
                    newPosition.Set(center.X + (normal.X > 0 ? distance : -distance), center.Y, center.Z);
                }

                View3D1.Camera.Position = newPosition;
                View3D1.Camera.LookAt(center);
                await View3D1.UpdateScene();
            }
        };

        // Handle dragging
        View3D1.OnMouseDown += async (e) =>
        {
            var intersected = await View3D1.RaycastAsync(e.X, e.Y);
            if (intersected != null && intersected.Object == navigationCube)
            {
                isDragging = true;
                lastX = e.X;
                lastY = e.Y;
                View3D1.OrbitControls.Enabled = false; // Disable default controls during drag
            }
        };

        View3D1.OnMouseMove += async (e) =>
        {
            if (isDragging)
            {
                var deltaX = e.X - lastX;
                var deltaY = e.Y - lastY;

                // Rotate camera around center
                var theta = deltaX * 0.005f; // Azimuth
                var phi = deltaY * 0.005f;   // Polar
                var currentPos = View3D1.Camera.Position;
                var offset = currentPos.Subtract(center);
                var radius = offset.Length();

                theta += (float)Math.Atan2(offset.Y, offset.X);
                phi = (float)Math.Acos(offset.Z / radius) + phi;
                phi = Math.Clamp(phi, 0.1f, MathF.PI - 0.1f); // Avoid poles

                offset.X = radius * (float)Math.Sin(phi) * (float)Math.Cos(theta);
                offset.Y = radius * (float)Math.Sin(phi) * (float)Math.Sin(theta);
                offset.Z = radius * (float)Math.Cos(phi);

                View3D1.Camera.Position = center.Add(offset);
                View3D1.Camera.LookAt(center);

                lastX = e.X;
                lastY = e.Y;
                await View3D1.UpdateScene();
            }
        };

        View3D1.OnMouseUp += (e) =>
        {
            if (isDragging)
            {
                isDragging = false;
                View3D1.OrbitControls.Enabled = true; // Re-enable default controls
            }
        };
    }

    private Task OnObjectLoaded(Object3DArgs e)
    {
        msg = $"Loaded object with id = {e.UUID}";
        StateHasChanged();
        return Task.CompletedTask;
    }
}
